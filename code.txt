void simulate_h2_excitation(const string& data_path, const string& sim_path, const string& output_path, double hcolumn_density, 
	int is_h2_pop_dens_init, double op_ratio_h2,
	int test_fast_electron_yields, double test_electron_conc, double test_electron_energy, double test_he_abund, double test_conc_h_tot, double test_ioniz_fract)
{
#ifdef __linux__
	stringstream lin_out;
	lin_out << output_path;
	lin_out << "out";
	lin_out << "_screen";
	lin_out << ".txt";
	// lin_out.str("/dev/null");

	//ofstream outerr(lin_out.str().c_str(), ios::app);
	//streambuf* orig_cerr = cerr.rdbuf(); // original cerr;
	//cerr.rdbuf(outerr.rdbuf());

	ofstream out(lin_out.str().c_str(), ios::app);
	streambuf* orig_cout = cout.rdbuf();
	cout.rdbuf(out.rdbuf());
#endif

	const int verbosity = 1;
	
	bool dust_is_presented(true), must_be_saved;
	int i, k, nb_of_time_moments, lay_nb, time_nb, step_nb, flag, nb_of_equat, nb_of_el_energies, nb_lev_h2, nb_lev_hei, 
		h2eq_nb, heieq_nb, physeq_nb;
	long int nb_steps_tot;
	double x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, rel_tol, dt, model_time, model_time_aux, model_time_aux_prev, model_time_step, model_time_out,
		conc_h_tot, ioniz_fract, grain_radius_init, grain_nb_density, grain_material_density, grain_radius, dust_mass, gas_mass, grb_distance, 
		dg_ratio, grb_cloud_distance;

	double enloss_rate_mt, enloss_rate_h2_rot, enloss_rate_h2_rot_pos, enloss_rate_h2_vibr, enloss_rate_h2_vibr_pos,
		enloss_rate_h2_singlet, enloss_rate_h2_triplet, enloss_rate_ioniz, enloss_rate_hei, enloss_rate_coulomb_el, diss_decay_heating_rate,
		neutral_coll_heating_rate; 
	
	double enloss_mt, enloss_h2_rot, enloss_h2_vibr, enloss_h2_singlet, enloss_h2_triplet, enloss_ioniz, enloss_hei,
		enloss_coulomb_el, diss_decay_heating, neutral_coll_heating;
		
	double h2_solomon_diss_rate, h2_diss_exc_singlet_rate, h2_diss_exc_triplet_rate, hei_exc_rate, h2_excit_electr_rate, h2_excit_vibr_rate, h2_excit_rot_rate, 
		h2_excit_electr_bs_rate, h2_excit_electr_cp_rate,  h2_excit_vibr_v1_rate, h2_excit_vibr_v2_rate, h2_excit_vibr_v3_rate, h2_el_excit_vstate_rate;
		
	double h2_solomon_diss, h2_diss_exc_singlet, h2_diss_exc_triplet, hei_exc, h2_excit_electr, h2_excit_vibr, h2_excit_rot, 
		h2_excit_electr_bs, h2_excit_electr_cp, h2_excit_vibr_v1, h2_excit_vibr_v2, h2_excit_vibr_v3, h2_el_excit_vstate;

	time_t timer;
	char* ctime_str;

	string fname;
	ofstream output;

	vector<int>    qnb_v_arr, qnb_j_arr;
	vector<double> time_cloud_arr;      // in s
	vector<double> layer_centre_distances;  // in cm
	vector<double> electron_energies_grid, electron_energy_bin_size;  // in eV,

	// Energy loss rates in [eV cm-3 s-1], as a function of time
	vector<double> enloss_rate_mt_arr, enloss_rate_h2_rot_arr, enloss_rate_h2_rot_arr_pos, enloss_rate_h2_vibr_arr, enloss_rate_h2_vibr_arr_pos, 
		enloss_rate_h2_singlet_arr, enloss_rate_h2_triplet_arr, enloss_rate_ioniz_arr, enloss_rate_hei_arr, 
		enloss_rate_coulomb_el_arr, diss_decay_heating_rate_arr, neutral_coll_heating_rate_arr;

	// Energy loss in [eV cm-3] during the time interval [0, t] as a function of time t,
	vector<double> enloss_mt_arr, enloss_h2_rot_arr, enloss_h2_vibr_arr, enloss_h2_singlet_arr, enloss_h2_triplet_arr, enloss_ioniz_arr, 
		enloss_hei_arr, enloss_coulomb_el_arr, diss_decay_heating_arr, neutral_coll_heating_arr;

	// Excitation rates in [cm-3 s-1], as a function of time
	vector<double> h2_excit_electr_rate_arr, h2_excit_vibr_rate_arr, h2_excit_rot_rate_arr;

	// Number of excitations in [cm-3] up to a given time, as a function of time
	vector<double> h2_excit_electr_arr, h2_excit_vibr_arr, h2_excit_rot_arr, 
		h2_excit_electr_bs_arr, h2_excit_electr_cp_arr, h2_excit_vibr_v1_arr, h2_excit_vibr_v2_arr, h2_excit_vibr_v3_arr, h2_excit_el_vstate_arr, 
		hei_exc_arr;

	// Dissociated concentration of H2 in [cm-3] up to a given time, as a function of time
	vector<double> h2_solomon_diss_arr, h2_diss_exc_singlet_arr, h2_diss_exc_triplet_arr;

	// Physical parameters as a function of time,
	vector<double> neutral_temp_arr, ion_temp_arr, dust_charge_arr;

	// Parameter[layer nb], at the fixed time (start of electron spectra simulations),
	vector<double> dg_ratio_cloud_data, ioniz_cloud_data;

	// Spectrum[layer nb][energy bin] in [cm-3 eV-1], vector index - layer nb, array index - energy bin nb (specimen nb, H2 level nb),
 	vector<dynamic_array> el_spectrum_init_data, specimen_conc_init_data; 
	vector<dynamic_array> h2_pop_dens_init_data;
	
	// Electron spectrum[time nb][energy bin] in [cm-3], vector index - time moment nb, array index - energy bin nb 
	vector<dynamic_array> el_spectrum_evol;
	// Concentration[time nb][specimen nb], or [level nb]
	vector<dynamic_array> specimen_conc_evol, h2_popdens_evol, h2_popdens_v_evol, hei_popul_dens_evol;  // in [cm-3]

	cout << scientific;
	cout.precision(3);

	timer = time(NULL);
	ctime_str = ctime(&timer);

	cout << ctime_str << endl
		<< "Start of the simulations of the evolution of electron spectra" << endl
		<< "Initialization of the data..." << endl;

	// initialization of the electron spectrum grid, that can be finer than the energy grid in the file with simulation data,
	init_electron_energy_grid(electron_energies_grid, electron_energy_bin_size);	
	nb_of_el_energies = (int)electron_energies_grid.size() - 1;
	
	dynamic_array el_spectrum_test(nb_of_el_energies);
	if (test_fast_electron_yields) 
	{
		init_electron_spectra_test(output_path, el_spectrum_test, electron_energies_grid, test_electron_conc, test_electron_energy);
		
		ioniz_fract = test_ioniz_fract;
		conc_h_tot = test_conc_h_tot;
		grb_cloud_distance = 0.;
		hcolumn_density = 0.;
		grb_distance = 0.;
		lay_nb = 0;
	}
	else
	{
		ioniz_fract = IONIZATION_FRACTION_THERMAL_EL;
		init_dust_abund(sim_path, dg_ratio_cloud_data, grain_radius_init, grain_nb_density, grain_material_density);

		// gas density and layer coordinates are initialized here,
		init_specimen_conc(sim_path, conc_h_tot, layer_centre_distances, specimen_conc_init_data);

		// electron spectrum in the file has the dimension [cm-3 eV-1],	
		init_electron_spectra(sim_path, output_path, el_spectrum_init_data, electron_energies_grid);

		// population density in the file has dimension [cm-3],
		init_h2_population_density(sim_path, h2_pop_dens_init_data, qnb_v_arr, qnb_j_arr);

		// distance from the GRB source to the cloud boundary (the layer width is the same for all layers),
		grb_cloud_distance = layer_centre_distances[0] - 0.5 * (layer_centre_distances[1] - layer_centre_distances[0]);

		// Simulations are carried out for fixed cloud layer,
		// Calculation of layer nb:
		for (lay_nb = 0; lay_nb < (int)layer_centre_distances.size(); lay_nb++) {
			if (hcolumn_density <= conc_h_tot * (layer_centre_distances[lay_nb] - grb_cloud_distance))
				break;
		}

		// updating column density for given layer number,
		hcolumn_density = conc_h_tot * (layer_centre_distances[lay_nb] - grb_cloud_distance);

		// distance from the GRB source to the centre of the particular cloud layer,
		grb_distance = layer_centre_distances[lay_nb];
	}

	elspectra_evolution_data user_data(data_path, output_path, conc_h_tot, ioniz_fract, electron_energies_grid, verbosity);

	nb_of_equat = user_data.get_nb_of_equat();
	nb_lev_h2 = user_data.get_nb_of_h2_lev();
	nb_lev_hei = user_data.get_nb_of_hei_lev();

	h2eq_nb = user_data.get_h2eq_nb();
	heieq_nb = user_data.get_heieq_nb();
	physeq_nb = user_data.get_physeq_nb();

	dynamic_array el_spectrum(nb_of_el_energies), specimen_conc(NB_OF_CHEM_SPECIES), h2_popul_dens(nb_lev_h2), hei_popul_dens(nb_lev_hei), 
		h2_pop_v(MAX_H2_VSTATES_X1SU);

	time_cloud_arr.clear();
	time_cloud_arr.push_back(0.);
	time_cloud_arr.push_back(MIN_MODEL_TIME);

	x1 = pow(10., 1. / NB_OF_BINS_PER_ORDER_TIME);
	
	for (i = 0; time_cloud_arr.back() < MAX_MODEL_TIME; i++) {
		time_cloud_arr.push_back(time_cloud_arr.back() * x1);
	}
	nb_of_time_moments = (int)time_cloud_arr.size();

	// initialization of vectors and matrices used by solver SUNDIALS CVODE
	N_Vector y, ydot, abs_tol;
	SUNMatrix A(NULL);
	SUNLinearSolver LS(NULL);

	y = N_VNew_Serial(nb_of_equat);
	ydot = N_VNew_Serial(nb_of_equat);
	abs_tol = N_VNew_Serial(nb_of_equat);

	model_time_aux = model_time = 0.;

	// Initialization for tolerances:
	rel_tol = REL_ERROR_SOLVER;
	user_data.set_tolerances(abs_tol);

	// Call CVodeCreate to create the solver memory and specify the Backward Differentiation Formula and the use of a Newton iteration 
	void* cvode_mem = CVodeCreate(CV_BDF);

	// Call CVodeInit to initialize the integrator memory and specify the user's right hand side function in y'=f(t,y), 
	// the initial time t0, and the initial dependent variable vector y;
	// y is not defined yet,
	flag = CVodeInit(cvode_mem, f_elsp, model_time, y);

	// Call CVodeSVtolerances to specify the scalar tolerances:
	flag = CVodeSVtolerances(cvode_mem, rel_tol, abs_tol);

	// The maximal number of steps between simulation stops;
	flag = CVodeSetMaxNumSteps(cvode_mem, 10000);

	// specifies the maximum number of error test failures permitted in attempting one step:
	flag = CVodeSetMaxErrTestFails(cvode_mem, MAX_ERR_TEST_FAILS_SOLVER); // default value is 7; 
	flag = CVodeSetMaxConvFails(cvode_mem, MAX_CONV_FAILS_SOLVER); // default value is 10;

	// Create dense SUNMatrix for use in linear solves 
	A = SUNDenseMatrix(nb_of_equat, nb_of_equat);

	// Create dense SUNLinearSolver object for use by CVode 
	LS = SUNDenseLinearSolver(y, A);

	// Call CVDlsSetLinearSolver to attach the matrix and linear solver to CVode 
	flag = CVDlsSetLinearSolver(cvode_mem, LS, A);

	// The function attaches the user data block to the solver;
	flag = CVodeSetUserData(cvode_mem, &user_data);

	// Initialization of initial values of variables,
	for (i = 0; i < nb_of_equat; i++) {
		NV_Ith_S(y, i) = 0.;
	}

	if (test_fast_electron_yields) {
		for (i = 0; i < nb_of_el_energies; i++) {
			// the number of electrons in the interval:
			NV_Ith_S(y, i) = el_spectrum_test.arr[i] * user_data.get_electron_energy_bin(i);
		}

		NV_Ith_S(y, nb_of_el_energies + H2_NB) = 0.5 * conc_h_tot;
		NV_Ith_S(y, nb_of_el_energies + HE_NB) = test_he_abund * conc_h_tot;

		// the initial distribution of energy level populations is postulated, [cm-3]
		NV_Ith_S(y, h2eq_nb) = NV_Ith_S(y, nb_of_el_energies + H2_NB) / (op_ratio_h2 + 1.);
		NV_Ith_S(y, h2eq_nb + 1) = NV_Ith_S(y, nb_of_el_energies + H2_NB) * op_ratio_h2 / (op_ratio_h2 + 1.);

		// the initial distribution of HeI levels,
		NV_Ith_S(y, heieq_nb) = NV_Ith_S(y, nb_of_el_energies + HE_NB);

		// Initial gas/dust temperature, in K
		NV_Ith_S(y, physeq_nb) = NV_Ith_S(y, physeq_nb + 1) = 10.;

		// Dust charge
		NV_Ith_S(y, physeq_nb + 2) = 0.;

		dust_is_presented = false;
		grain_radius = 0.;
		grain_nb_density = 0.;
		dg_ratio = 0.;

		user_data.set_dust_parameters(dust_is_presented, grain_radius, grain_nb_density);
	}
	else {
		for (i = 0; i < nb_of_el_energies; i++) {
			// the number of electrons in the interval:
			NV_Ith_S(y, i) = el_spectrum_init_data[lay_nb].arr[i] * user_data.get_electron_energy_bin(i);
		}

		for (i = 0; i < NB_OF_CHEM_SPECIES; i++) {
			NV_Ith_S(y, nb_of_el_energies + i) = specimen_conc_init_data[lay_nb].arr[i];
		}

		if (is_h2_pop_dens_init) {
			// population densities must be in [cm-3],
			x1 = x2 = 0.;
			for (i = 0; i < h2_pop_dens_init_data[lay_nb].dim; i++) 
			{
				k = user_data.get_level_nb_h2(qnb_v_arr[i], qnb_j_arr[i]);
				if (k >= 0) {
					NV_Ith_S(y, h2eq_nb + k) = h2_pop_dens_init_data[lay_nb].arr[i];
				}

				if (qnb_j_arr[i] % 2 == 0) {
					x2 += h2_pop_dens_init_data[lay_nb].arr[i];
				}
				else {
					x1 += h2_pop_dens_init_data[lay_nb].arr[i];
				}
			}
			// calculating of ortho-para-H2 ratio,
			op_ratio_h2 = x1 / x2;
		}
		else {
			// the initial distribution of energy level populations is postulated, [cm-3]
			NV_Ith_S(y, h2eq_nb) = NV_Ith_S(y, nb_of_el_energies + H2_NB) / (op_ratio_h2 + 1.);
			NV_Ith_S(y, h2eq_nb + 1) = NV_Ith_S(y, nb_of_el_energies + H2_NB) * op_ratio_h2 / (op_ratio_h2 + 1.);
		}

		// the initial distribution of HeI levels,
		NV_Ith_S(y, heieq_nb) = NV_Ith_S(y, nb_of_el_energies + HE_NB);

		// Initial gas/dust temperature, in K
		NV_Ith_S(y, physeq_nb) = NV_Ith_S(y, physeq_nb + 1) = 10.;

		// Dust charge
		NV_Ith_S(y, physeq_nb + 2) = 0.;

		gas_mass = specimen_conc_init_data[lay_nb].arr[H_NB] + specimen_conc_init_data[lay_nb].arr[H_P_NB]
			+ 2. * (specimen_conc_init_data[lay_nb].arr[H2_NB] + specimen_conc_init_data[lay_nb].arr[H2_P_NB])
			+ 4. * (specimen_conc_init_data[lay_nb].arr[HE_NB] + specimen_conc_init_data[lay_nb].arr[HE_P_NB] + specimen_conc_init_data[lay_nb].arr[HE_PP_NB]);
		gas_mass *= ATOMIC_MASS_UNIT;

		// dust-gas mass ratio < 1.
		dust_mass = gas_mass * dg_ratio_cloud_data[lay_nb] / (1. - dg_ratio_cloud_data[lay_nb]);

		// calculation of grain cross section,
		if (dg_ratio_cloud_data[lay_nb] <= numeric_limits<double>::epsilon()) {
			dust_is_presented = false;
			grain_radius = 0.;
			dg_ratio = 0.;
		}
		else {
			dust_is_presented = true;
			x1 = dust_mass * 3. / (grain_nb_density * grain_material_density * 4. * M_PI);
			grain_radius = pow(x1, 1. / 3.);   // grain radius, cm
			dg_ratio = dg_ratio_cloud_data[lay_nb];
		}
		user_data.set_dust_parameters(dust_is_presented, grain_radius, grain_nb_density);
	}
	
	// restart of the solver with new values of initial conditions,
	flag = CVodeReInit(cvode_mem, model_time, y);

	// update the members of user_data class,
	f_elsp(model_time, y, ydot, &user_data);

	enloss_rate_mt = enloss_rate_h2_rot = enloss_rate_h2_rot_pos = enloss_rate_h2_vibr = enloss_rate_h2_vibr_pos = enloss_rate_h2_singlet 
		= enloss_rate_h2_triplet = enloss_rate_ioniz = enloss_rate_hei = enloss_rate_coulomb_el = diss_decay_heating_rate = neutral_coll_heating_rate = 0.;

	enloss_mt = enloss_h2_rot = enloss_h2_vibr = enloss_h2_singlet = enloss_h2_triplet = enloss_ioniz = enloss_hei 
		= enloss_coulomb_el = diss_decay_heating = neutral_coll_heating  = 0.;

	h2_solomon_diss_rate = h2_diss_exc_singlet_rate = h2_diss_exc_triplet_rate = 0.;
	h2_solomon_diss = h2_diss_exc_singlet = h2_diss_exc_triplet = 0.;

	h2_excit_electr_rate = h2_excit_vibr_rate = h2_excit_rot_rate 
		= h2_excit_electr_bs_rate = h2_excit_electr_cp_rate = h2_excit_vibr_v1_rate = h2_excit_vibr_v2_rate = h2_excit_vibr_v3_rate 
		= h2_el_excit_vstate_rate = hei_exc_rate = 0.;
	
	h2_excit_electr = h2_excit_vibr = h2_excit_rot 
		= h2_excit_electr_bs = h2_excit_electr_cp = h2_excit_vibr_v1 = h2_excit_vibr_v2 = h2_excit_vibr_v3 = h2_el_excit_vstate = hei_exc = 0.;

	// for initial time moment:
	for (i = 0; i < nb_of_el_energies; i++) {
		el_spectrum.arr[i] = NV_Ith_S(y, i);  // number of electrons in the energy interval (is not divided by energy bin),
	}
	el_spectrum_evol.push_back(el_spectrum);

	for (i = 0; i < NB_OF_CHEM_SPECIES; i++) {
		specimen_conc.arr[i] = NV_Ith_S(y, nb_of_el_energies + i);
	}
	specimen_conc_evol.push_back(specimen_conc);

	for (i = 0; i < nb_lev_h2; i++) {
		h2_popul_dens.arr[i] = NV_Ith_S(y, h2eq_nb + i);
	}
	h2_popdens_evol.push_back(h2_popul_dens);

	memset(h2_pop_v.arr, 0, MAX_H2_VSTATES_X1SU * sizeof(double));
	for (i = 0; i < nb_lev_h2; i++) {
		k = user_data.get_vibr_nb_h2(i);
		if (k >= 0)
			h2_pop_v.arr[k] += NV_Ith_S(y, h2eq_nb + i);
	}
	h2_popdens_v_evol.push_back(h2_pop_v);

	for (i = 0; i < nb_lev_hei; i++) {
		hei_popul_dens.arr[i] = NV_Ith_S(y, heieq_nb + i);
	}
	hei_popul_dens_evol.push_back(hei_popul_dens);

	// Energy loss rates
	enloss_rate_mt_arr.push_back(enloss_rate_mt);
	enloss_rate_h2_rot_arr.push_back(enloss_rate_h2_rot);
	enloss_rate_h2_vibr_arr.push_back(enloss_rate_h2_vibr);
	enloss_rate_h2_singlet_arr.push_back(enloss_rate_h2_singlet);
	enloss_rate_h2_triplet_arr.push_back(enloss_rate_h2_triplet);
	enloss_rate_ioniz_arr.push_back(enloss_rate_ioniz);
	enloss_rate_hei_arr.push_back(enloss_rate_hei);

	enloss_rate_coulomb_el_arr.push_back(enloss_rate_coulomb_el);
	diss_decay_heating_rate_arr.push_back(diss_decay_heating_rate);
	neutral_coll_heating_rate_arr.push_back(neutral_coll_heating_rate);
	
	enloss_rate_h2_rot_arr_pos.push_back(enloss_rate_h2_rot_pos);
	enloss_rate_h2_vibr_arr_pos.push_back(enloss_rate_h2_vibr_pos);
	
	// energy losses, time-integrated
	enloss_mt_arr.push_back(enloss_mt);
	enloss_h2_rot_arr.push_back(enloss_h2_rot);
	enloss_h2_vibr_arr.push_back(enloss_h2_vibr);
	enloss_h2_singlet_arr.push_back(enloss_h2_singlet);
	enloss_h2_triplet_arr.push_back(enloss_h2_triplet);
	enloss_ioniz_arr.push_back(enloss_ioniz);
	enloss_hei_arr.push_back(enloss_hei);

	enloss_coulomb_el_arr.push_back(enloss_coulomb_el);
	diss_decay_heating_arr.push_back(diss_decay_heating);
	neutral_coll_heating_arr.push_back(neutral_coll_heating);
	
	// Excitation rates,
	h2_excit_electr_rate_arr.push_back(h2_excit_electr_rate);
	h2_excit_vibr_rate_arr.push_back(h2_excit_vibr_rate);
	h2_excit_rot_rate_arr.push_back(h2_excit_rot_rate);

	// Excitation, time-integrated
	h2_excit_electr_arr.push_back(h2_excit_electr);
	h2_excit_vibr_arr.push_back(h2_excit_vibr);
	h2_excit_rot_arr.push_back(h2_excit_rot);

	h2_excit_electr_bs_arr.push_back(h2_excit_electr_bs);
	h2_excit_electr_cp_arr.push_back(h2_excit_electr_cp);
	
	h2_excit_vibr_v1_arr.push_back(h2_excit_vibr_v1);
	h2_excit_vibr_v2_arr.push_back(h2_excit_vibr_v2);
	h2_excit_vibr_v3_arr.push_back(h2_excit_vibr_v3);
	h2_excit_el_vstate_arr.push_back(h2_el_excit_vstate_rate);

	hei_exc_arr.push_back(hei_exc);

	// Dissociation, time-integrated
	h2_solomon_diss_arr.push_back(h2_solomon_diss);
	h2_diss_exc_singlet_arr.push_back(h2_diss_exc_singlet);
	h2_diss_exc_triplet_arr.push_back(h2_diss_exc_triplet);
	
	neutral_temp_arr.push_back(NV_Ith_S(y, physeq_nb));
	ion_temp_arr.push_back(NV_Ith_S(y, physeq_nb + 1));
	dust_charge_arr.push_back(NV_Ith_S(y, physeq_nb + 2) * grain_nb_density);  // dust charge per cm3

	// Start of the simulations: 
	cout << left << "Initialization step time (s): " << setw(12) << (int)(time(NULL) - timer) << endl
		<< "Starting simulations..." << endl;
	timer = time(NULL);

	if (verbosity) {
		cout << left << "lay_nb: " << lay_nb << endl
			<< left << setw(12) << "model_time " << setw(9) << "steps_nb "
			<< setw(12) << "gas_temp(K)" << setw(12) << "ion_temp(K)" << setw(12) << "dust_charge" << endl;
	}

	save_model_parameters(output_path, grb_cloud_distance, grb_distance, hcolumn_density, conc_h_tot,
		op_ratio_h2, dg_ratio, grain_radius, grain_nb_density, lay_nb);

	time_nb = 1;
	// there is integration of the parameters over the time, this time step must be sufficiently small, 
	model_time_step = 1.;

	while (model_time < time_cloud_arr.back()) 
	{	
		flag = CV_SUCCESS;
		must_be_saved = false;
		model_time_aux_prev = model_time_aux;

		if (model_time < time_cloud_arr[time_nb]) 
		{
			step_nb = 0;
			model_time_out = model_time + model_time_step;  // ?
			
			while (step_nb < MAX_NB_STEPS && flag == CV_SUCCESS && model_time < model_time_out) 
			{
				// actual model time is stored in cvode_mem, 
				flag = CVode(cvode_mem, model_time_out, y, &model_time, CV_ONE_STEP);  // CV_NORMAL or CV_ONE_STEP	
				step_nb++;
			}
		}
		
		if (flag == CV_SUCCESS) {	
			if (model_time > time_cloud_arr[time_nb]) {
				// step back to the time grid value, updating model time,
				flag = CVodeGetDky(cvode_mem, time_cloud_arr[time_nb], 0, y);
				model_time_aux = time_cloud_arr[time_nb];

				must_be_saved = true;
				time_nb++;
				
				if (flag != CV_SUCCESS) {
					cout << "Error in CVodeGetDky() " << flag << endl;
				}
			}
			else {
				model_time_aux = model_time;
			}
			
			// update the members of user_data class,
			f_elsp(model_time_aux, y, ydot, &user_data);
			
			dt = 0.5 * (model_time_aux - model_time_aux_prev);

			// Energy losses, 
			x1 = enloss_rate_mt;
			x2 = enloss_rate_h2_rot;
			x3 = enloss_rate_h2_vibr;
			x4 = enloss_rate_h2_singlet;
			x5 = enloss_rate_ioniz;
			x6 = enloss_rate_hei;
			x7 = enloss_rate_h2_triplet;

			x8 = enloss_rate_coulomb_el;
			x9 = diss_decay_heating_rate;
			x10 = neutral_coll_heating_rate;
			
			user_data.get_el_energy_losses(enloss_rate_mt, enloss_rate_h2_rot, enloss_rate_h2_rot_pos, enloss_rate_h2_vibr, enloss_rate_h2_vibr_pos, 
				enloss_rate_h2_singlet, enloss_rate_h2_triplet, enloss_rate_ioniz, enloss_rate_hei, enloss_rate_coulomb_el, 
				diss_decay_heating_rate, neutral_coll_heating_rate);

			enloss_mt += (x1 + enloss_rate_mt) * dt;
			enloss_h2_rot += (x2 + enloss_rate_h2_rot) * dt;
			enloss_h2_vibr += (x3 + enloss_rate_h2_vibr) * dt;
			enloss_h2_singlet += (x4 + enloss_rate_h2_singlet) * dt;
			enloss_ioniz += (x5 + enloss_rate_ioniz) * dt;
			enloss_hei += (x6 + enloss_rate_hei) * dt;
			enloss_h2_triplet += (x7 + enloss_rate_h2_triplet) * dt;

			enloss_coulomb_el += (x8 + enloss_rate_coulomb_el) * dt;
			diss_decay_heating += (x9 + diss_decay_heating_rate) * dt;
			neutral_coll_heating += (x10 + neutral_coll_heating_rate) * dt;
			
			// Dissociation rates
			x1 = h2_solomon_diss_rate;
			x2 = h2_diss_exc_singlet_rate;
			x3 = h2_diss_exc_triplet_rate;

			user_data.get_h2_diss_rates(h2_solomon_diss_rate, h2_diss_exc_singlet_rate, h2_diss_exc_triplet_rate);

			h2_solomon_diss += (x1 + h2_solomon_diss_rate) * dt;
			h2_diss_exc_singlet += (x2 + h2_diss_exc_singlet_rate) * dt;
			h2_diss_exc_triplet += (x3 + h2_diss_exc_triplet_rate) * dt;

			// Excitation rates,
			x1 = h2_excit_electr_rate;
			x2 = h2_excit_vibr_rate;
			x3 = h2_excit_rot_rate;
			
			x4 = h2_excit_electr_bs_rate;
			x5 = h2_excit_electr_cp_rate;

			x6 = h2_excit_vibr_v1_rate;
			x7 = h2_excit_vibr_v2_rate;
			x8 = h2_excit_vibr_v3_rate;
			x9 = h2_el_excit_vstate_rate;
			
			x10 = hei_exc_rate;

			user_data.get_h2_process_rates(h2_excit_electr_rate, h2_excit_vibr_rate, h2_excit_rot_rate, 
				h2_excit_electr_bs_rate, h2_excit_electr_cp_rate, h2_excit_vibr_v1_rate, h2_excit_vibr_v2_rate, h2_excit_vibr_v3_rate, 
				h2_el_excit_vstate_rate, hei_exc_rate);
			
			h2_excit_electr += (x1 + h2_excit_electr_rate) * dt;
			h2_excit_vibr += (x2 + h2_excit_vibr_rate) * dt;
			h2_excit_rot += (x3 + h2_excit_rot_rate) * dt;

			h2_excit_electr_bs += (x4 + h2_excit_electr_bs_rate) * dt;
			h2_excit_electr_cp += (x5 + h2_excit_electr_cp_rate) * dt;
			
			h2_excit_vibr_v1 += (x6 + h2_excit_vibr_v1_rate) * dt;
			h2_excit_vibr_v2 += (x7 + h2_excit_vibr_v2_rate) * dt;
			h2_excit_vibr_v3 += (x8 + h2_excit_vibr_v3_rate) * dt;
			h2_el_excit_vstate += (x9 + h2_el_excit_vstate_rate) * dt;
			
			hei_exc += (x10 + hei_exc_rate) * dt;

			flag = CVodeGetNumSteps(cvode_mem, &nb_steps_tot);

			if (verbosity) {
				cout.precision(2);
				cout << left << setw(12) << model_time_aux << setw(9) << nb_steps_tot <<
					setw(12) << NV_Ith_S(y, physeq_nb) << setw(12) << NV_Ith_S(y, physeq_nb + 1) << setw(12) << NV_Ith_S(y, physeq_nb + 2) << endl;
			}
		
			// saving data,
			if (must_be_saved) {
				for (i = 0; i < nb_of_el_energies; i++) {
					el_spectrum.arr[i] = NV_Ith_S(y, i);  // number of electrons in the energy interval (is not divided by energy bin),
				}
				el_spectrum_evol.push_back(el_spectrum);

				for (i = 0; i < NB_OF_CHEM_SPECIES; i++) {
					specimen_conc.arr[i] = NV_Ith_S(y, nb_of_el_energies + i);
				}
				specimen_conc_evol.push_back(specimen_conc);

				for (i = 0; i < nb_lev_h2; i++) {
					h2_popul_dens.arr[i] = NV_Ith_S(y, h2eq_nb + i);
				}
				h2_popdens_evol.push_back(h2_popul_dens);

				memset(h2_pop_v.arr, 0, MAX_H2_VSTATES_X1SU * sizeof(double));
				for (i = 0; i < nb_lev_h2; i++) {
					k = user_data.get_vibr_nb_h2(i);
					if (k >= 0)
						h2_pop_v.arr[k] += NV_Ith_S(y, h2eq_nb + i);
				}
				h2_popdens_v_evol.push_back(h2_pop_v);

				for (i = 0; i < nb_lev_hei; i++) {
					hei_popul_dens.arr[i] = NV_Ith_S(y, heieq_nb + i);
				}
				hei_popul_dens_evol.push_back(hei_popul_dens);

				// Energy losses, rates
				enloss_rate_mt_arr.push_back(enloss_rate_mt);
				enloss_rate_h2_rot_arr.push_back(enloss_rate_h2_rot);
				enloss_rate_h2_vibr_arr.push_back(enloss_rate_h2_vibr);
				enloss_rate_h2_singlet_arr.push_back(enloss_rate_h2_singlet);
				enloss_rate_h2_triplet_arr.push_back(enloss_rate_h2_triplet);
				enloss_rate_ioniz_arr.push_back(enloss_rate_ioniz);
				enloss_rate_hei_arr.push_back(enloss_rate_hei);
				
				enloss_rate_coulomb_el_arr.push_back(enloss_rate_coulomb_el);
				diss_decay_heating_rate_arr.push_back(diss_decay_heating_rate);
				neutral_coll_heating_rate_arr.push_back(neutral_coll_heating_rate);
				
				enloss_rate_h2_rot_arr_pos.push_back(enloss_rate_h2_rot_pos);
				enloss_rate_h2_vibr_arr_pos.push_back(enloss_rate_h2_vibr_pos);
				
				// energy losses, time-integrated,
				enloss_mt_arr.push_back(enloss_mt);
				enloss_h2_rot_arr.push_back(enloss_h2_rot);
				enloss_h2_vibr_arr.push_back(enloss_h2_vibr);
				enloss_h2_singlet_arr.push_back(enloss_h2_singlet);
				enloss_h2_triplet_arr.push_back(enloss_h2_triplet);
				enloss_ioniz_arr.push_back(enloss_ioniz);
				enloss_hei_arr.push_back(enloss_hei);

				enloss_coulomb_el_arr.push_back(enloss_coulomb_el);
				diss_decay_heating_arr.push_back(diss_decay_heating);
				neutral_coll_heating_arr.push_back(neutral_coll_heating);
				
				// Excitations, rates
				h2_excit_electr_rate_arr.push_back(h2_excit_electr_rate);
				h2_excit_vibr_rate_arr.push_back(h2_excit_vibr_rate);
				h2_excit_rot_rate_arr.push_back(h2_excit_rot_rate);

				// Excitations, time-integrated,
				h2_excit_electr_arr.push_back(h2_excit_electr);
				h2_excit_vibr_arr.push_back(h2_excit_vibr);
				h2_excit_rot_arr.push_back(h2_excit_rot);
				
				h2_excit_electr_bs_arr.push_back(h2_excit_electr_bs);
				h2_excit_electr_cp_arr.push_back(h2_excit_electr_cp);

				h2_excit_vibr_v1_arr.push_back(h2_excit_vibr_v1);
				h2_excit_vibr_v2_arr.push_back(h2_excit_vibr_v2);
				h2_excit_vibr_v3_arr.push_back(h2_excit_vibr_v3);
				h2_excit_el_vstate_arr.push_back(h2_el_excit_vstate);
				
				hei_exc_arr.push_back(hei_exc);
				
				// Dissociations, time-integrated,
				h2_solomon_diss_arr.push_back(h2_solomon_diss);
				h2_diss_exc_singlet_arr.push_back(h2_diss_exc_singlet);
				h2_diss_exc_triplet_arr.push_back(h2_diss_exc_triplet);

				neutral_temp_arr.push_back(NV_Ith_S(y, physeq_nb));
				ion_temp_arr.push_back(NV_Ith_S(y, physeq_nb + 1));
				dust_charge_arr.push_back(NV_Ith_S(y, physeq_nb + 2) * grain_nb_density);  // dust charge per cm3

				save_electron_spectrum_evolution(output_path, electron_energies_grid, electron_energy_bin_size, time_cloud_arr, el_spectrum_evol, conc_h_tot);

				save_specimen_conc_evolution(output_path, time_cloud_arr, specimen_conc_evol, conc_h_tot);

				save_h2_populations_evolution(output_path, time_cloud_arr, h2_popdens_evol, h2_popdens_v_evol, conc_h_tot, nb_lev_h2);
			
				save_hei_populations_evolution(output_path, time_cloud_arr, hei_popul_dens_evol, conc_h_tot, nb_lev_hei);

				save_electron_energy_loss_rates(output_path, conc_h_tot, time_cloud_arr,
					enloss_rate_mt_arr, 
					enloss_rate_h2_rot_arr,
					enloss_rate_h2_rot_arr_pos,
					enloss_rate_h2_vibr_arr,
					enloss_rate_h2_vibr_arr_pos,
					enloss_rate_h2_singlet_arr,
					enloss_rate_h2_triplet_arr,
					enloss_rate_ioniz_arr, 
					enloss_rate_hei_arr, 
					enloss_rate_coulomb_el_arr,
					diss_decay_heating_rate_arr,
					neutral_coll_heating_rate_arr);

				save_electron_energy_losses(output_path, conc_h_tot, time_cloud_arr,
					enloss_mt_arr,
					enloss_h2_rot_arr,
					enloss_h2_vibr_arr,
					enloss_h2_singlet_arr,
					enloss_h2_triplet_arr,
					enloss_ioniz_arr,
					enloss_hei_arr, 
					enloss_coulomb_el_arr, 
					diss_decay_heating_arr, 
					neutral_coll_heating_arr);

				save_excit_rates(output_path, conc_h_tot, time_cloud_arr, 
					h2_excit_electr_rate_arr, h2_excit_vibr_rate_arr, h2_excit_rot_rate_arr);

				save_excit(output_path, conc_h_tot, time_cloud_arr, 
					h2_excit_electr_arr, 
					h2_excit_vibr_arr, 
					h2_excit_rot_arr,
					h2_excit_electr_bs_arr,
					h2_excit_electr_cp_arr,
					h2_excit_vibr_v1_arr, 
					h2_excit_vibr_v2_arr, 
					h2_excit_vibr_v3_arr,
					h2_excit_el_vstate_arr,
					hei_exc_arr);

				save_diss(output_path, conc_h_tot, time_cloud_arr,
					h2_solomon_diss_arr,
					h2_diss_exc_singlet_arr,
					h2_diss_exc_triplet_arr);

				save_phys_parameters(output_path, time_cloud_arr, neutral_temp_arr, ion_temp_arr, dust_charge_arr, specimen_conc_evol, conc_h_tot);
			}
		}
		else {
			cout << "Some unexpected error has been occurred: " << flag << endl;
			break;
		}
	}
	cout << left << "Total calculation time (s): " << setw(12) << (int)(time(NULL) - timer) << endl;
	
	// Saving parameters of the electron energy degradation,
	fname = output_path + "h2grb_parameters_output.txt";
	output.open(fname.c_str());

	output << scientific;
	output.precision(4);

	// Energy in electrons, number density of electrons at the start of simulations,
	x3 = x4 = 0.;
	for (i = 0; i < nb_of_el_energies; i++) {
		x3 += el_spectrum_evol.front().arr[i] * 0.5 * (electron_energies_grid[i] + electron_energies_grid[i + 1]);  // [eV cm-3]
		x4 += el_spectrum_evol.front().arr[i];  // [cm-3]
	}

	// simple species are: "e-", "H", "H+", "H2", "H2+", "He", "He+", "He++"
	// number density of ions produced, at the start of the simulations,
	x1 = specimen_conc_evol.front().arr[2] + specimen_conc_evol.front().arr[4] + specimen_conc_evol.front().arr[6]
		+ 2. * specimen_conc_evol.front().arr[7];  // [cm-3]

	// number density of ions produced, at the end of the simulations,
	x2 = specimen_conc_evol.back().arr[2] + specimen_conc_evol.back().arr[4] + specimen_conc_evol.back().arr[6]
		+ 2. * specimen_conc_evol.back().arr[7];  // [cm-3]
		
	output << left << "Parameters of the electron energy degradation:" << endl
		<< setw(38) << "Initial number of electrons, [cm-3]: "<< x4 << endl
		<< setw(38) << "Number of ionizations N[cm-3]: "      << x2 - x1 << endl
		<< setw(38) << "Initial electron energy E[eV cm-3]: " << x3 << endl
		<< setw(38) << "Mean energy per ion pair W: "         << x3 / (x2 - x1) << endl
		<< setw(38) << "Heating efficiency of neutral gas: "  << (fabs(enloss_mt_arr.back()) + neutral_coll_heating_arr.back()) / x3 << endl
		<< setw(38) << "Heating efficiency of electrons: "    << fabs(enloss_coulomb_el_arr.back()) / x3 << endl
		<< setw(38) << "Energy fraction lost in ro-vibr.: "   << fabs(enloss_h2_vibr_arr.back()) / x3 << endl;

	x4 = h2_diss_exc_singlet_arr.back() + h2_diss_exc_triplet_arr.back() + h2_solomon_diss_arr.back();

	output << left
		<< setw(38) << "H2 dissociations [cm-3]: " << x4 << endl
		<< setw(38) << "H2 dissociations, per ion pair: " << x4 / (x2 - x1) << endl
		<< setw(38) << "Electronic excitation, per ion pair" << h2_excit_electr_arr.back() / (x2 - x1) << endl
		<< setw(38) << "Excitation to B1S+u, per ion pair: " << h2_excit_electr_bs_arr.back() / (x2 - x1) << endl
		<< setw(38) << "Excitation to C1Pu, per ion pair: " << h2_excit_electr_cp_arr.back() / (x2 - x1) << endl
		<< setw(38) << "Vibr. excitation [cm-3]: " << h2_excit_vibr_arr.back() << endl
		<< setw(38) << "Vibr. excitation to v=1 [cm-3]: " << h2_excit_vibr_v1_arr.back() << endl
		<< setw(38) << "Ratio of excitations v=2/v=1: " << h2_excit_vibr_v2_arr.back() / h2_excit_vibr_v1_arr.back() << endl
		<< setw(38) << "Ratio of excitations v=3/v=1: " << h2_excit_vibr_v3_arr.back() / h2_excit_vibr_v1_arr.back() << endl
		<< setw(34) << "Electronic excitation [cm-3], v = " << CALC_EL_PUMPING_VSTATE_NB << " : " << h2_excit_el_vstate_arr.back() << endl;
	
	output.close();

	if (verbosity) {
		cout << "The memory is freeing up" << endl;
	}
	N_VDestroy(y);
	N_VDestroy(ydot);
	N_VDestroy(abs_tol);

	// Free integrator memory
	CVodeFree(&cvode_mem);

	// Free the linear solver memory
	SUNLinSolFree(LS);

	// Free the matrix memory
	SUNMatDestroy(A);
}
